//@version=6
strategy("Darvas Box Strategy", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=10, commission_value=0.1, max_labels_count=500, max_boxes_count=500)

// =============================================================================
//                            CONFIGURATION (INPUTS)
// =============================================================================

// -- Optional Annual High Filter
useAnnualHighFilter = input.bool(false, title="Use Annual High Proximity Filter", group="Filters", tooltip="Only form boxes when price is near its annual high. Helps filter for strongest stocks.")
annualLookback      = input.int(252, title="Annual High Lookback (days)", group="Filters", minval=50, tooltip="Period to calculate annual high. 252 = ~1 trading year")
nearHighPercent     = input.float(5.0, title="Proximity to Annual High (%)", group="Filters", minval=0.0, tooltip="How close price must be to annual high to qualify. 5% means within 5% of the high.")

// -- Relative High Lookback Period
recentHighLookback  = input.int(20, title="Relative High Lookback Period (days)", group="Filters", minval=5, tooltip="Period to look back for relative highs. 252 = ~1 year, 20 = ~1 month")

// -- Darvas Box Confirmation (classic)
ceilingConfirmationDays = input.int(3, title="Bars to Confirm Box Ceiling", group="Box Logic", minval=2, tooltip="Number of bars without new highs to confirm box ceiling. Classic Darvas uses 3.")
floorConfirmationDays   = input.int(3, title="Bars to Confirm Box Floor", group="Box Logic", minval=2, tooltip="Number of bars without new lows to confirm box floor. Classic Darvas uses 3.")

// -- Minimum box quality filters
minBarsInBox            = input.int(6, title="Minimum Bars Inside Box", group="Box Logic", minval=3, tooltip="Minimum width of box in bars. Filters out narrow/short-lived boxes.")
minBoxHeightPct         = input.float(1.0, title="Minimum Box Height (%)", group="Box Logic", minval=0.0, tooltip="Minimum height of box as percentage. 1% means box must be at least 1% from floor to ceiling.")

// -- Floor confirmation latency
minBarsAfterHighForFloor = input.int(1, title="Min Bars After High Before Floor Search", group="Box Logic", minval=0, tooltip="Bars to wait after ceiling confirmation before starting floor search. Ensures proper pullback.")

// -- Breakout tolerance
breakoutTolerancePct = input.float(0.0, title="Breakout Tolerance (%)", group="Box Logic", minval=0.0, maxval=5.0, tooltip="Percentage tolerance for breakouts. Prevents box closure from minor wicks. 0.0% = immediate breakout detection.")

// -- Volume Filter (only at breakout)
useVolumeFilter     = input.bool(true, title="Enable Volume Filter on Breakout", group="Filters", tooltip="Require high volume on breakout. Helps confirm genuine breakouts vs false signals.")
volumeLookback      = input.int(50, title="Volume MA Period", group="Filters", minval=5, tooltip="Period for volume moving average calculation. Used as baseline for volume comparison.")
volumeMultiplier    = input.float(1.5, title="Volume Multiplier (e.g., 1.5 = 50% above average)", group="Filters", minval=1.0, tooltip="Volume must be this many times above average. 1.5 = 50% above average volume.")

// -- Market Trend Filter
useMarketFilter     = input.bool(true, title="Enable Market Trend Filter", group="Filters", tooltip="Only trade when overall market is bullish. Darvas emphasized market conditions.")
marketTicker        = input.symbol("SPY", title="Market Index Ticker", group="Filters", tooltip="Market index to use for trend filter. SPY = S&P 500, QQQ = Nasdaq, etc.")
marketLookback      = input.int(200, title="Market SMA Period", group="Filters", minval=50, tooltip="SMA period for market trend. Market bullish when above this SMA. 200 is common long-term trend.")

// -- Visuals
showAnnualHigh      = input.bool(true, title="Show Annual High Line", group="Visualization", tooltip="Display the annual high line on chart for reference.")
boxColor            = input.color(color.new(color.blue, 80), title="Box Color", group="Visualization", tooltip="Color and transparency for Darvas boxes. Lighter colors show more price action.")
showDebugLabels     = input.bool(false, title="Show Debug Labels", group="Visualization", tooltip="Show debug information about box state and breakout detection.")
debugStartDate      = input.time(timestamp("01 Jan 2024"), title="Debug Start Date", group="Visualization", tooltip="Start date for showing debug labels")
debugEndDate        = input.time(timestamp("31 Dec 2024"), title="Debug End Date", group="Visualization", tooltip="End date for showing debug labels")

// =============================================================================
//                               CALCULATIONS
// =============================================================================

// Market Condition
marketClose = request.security(marketTicker, "1D", close)
marketSma   = ta.sma(marketClose, marketLookback)
isBullMarket = useMarketFilter ? (marketClose > marketSma) : true

// Annual high proximity (optional)
float fiftyTwoWeekHigh = ta.highest(high[1], annualLookback)
isNear52WeekHigh = high > fiftyTwoWeekHigh * (1 - nearHighPercent / 100)
passAnnualFilter = useAnnualHighFilter ? isNear52WeekHigh : true

// Relative high detection
float recentHigh = ta.highest(high[1], recentHighLookback)
newRelativeHigh = high > recentHigh

// Volume
float avgVolume       = ta.sma(volume[1], volumeLookback)
volumeOnBreakout = useVolumeFilter ? (volume > avgVolume * volumeMultiplier) : true

// Helper function to determine if we should show debug labels (only in specified date range)
shouldShowDebug() => showDebugLabels and (time >= debugStartDate and time <= debugEndDate)

// =============================================================================
//                         DARVAS BOX FORMATION LOGIC
//   Thesis rules:
//   - Start tracking after a new relative high (configurable lookback period).
//   - Confirm ceiling: configurable days WITHOUT a higher high.
//   - Confirm floor: configurable days WITHOUT a lower low (ignore closes).
//   - Volume only required on breakout above confirmed ceiling.
// =============================================================================

var string boxState = "IDLE"  // IDLE, SEEKING_CEILING_CONF, CEILING_CONFIRMED, SEEKING_FLOOR_CONF, BOX_FULLY_CONFIRMED
var float potentialCeiling = na
var float potentialFloor   = na
var float confirmedCeiling = na
var float confirmedFloor   = na
var int   ceilingConfDaysCount = 0
var int   floorConfDaysCount   = 0
var int   highBarIndex = na
var int   lowBarIndex  = na

// -- Additional state variables for classic Darvas method
var int   barsSinceHigh = na
var float runningFloorMin = na
var bool  boxWasBroken = false

// Single active Darvas box (only one at a time per Darvas methodology)
var box currentBox = na
var float currentBoxTop = na
var float currentBoxBottom = na

// Trade tracking variables
var float entryBoxTop = na
var float currentStopLoss = na

// Check for breakout of current active box
hasBreakout = false
float breakoutBoxTop = na
float breakoutBoxBottom = na

if not na(currentBoxTop) and not na(currentBoxBottom)
    // Apply same tolerance for trading breakouts
    tradingToleranceUp = currentBoxTop * (1 + breakoutTolerancePct / 100)
    if high > tradingToleranceUp  // Use tolerance for trading decisions too
        hasBreakout := true
        breakoutBoxTop := currentBoxTop
        breakoutBoxBottom := currentBoxBottom

// ----------------------- State Machine -----------------------
if isBullMarket and passAnnualFilter

    // COMMENTED OUT: Priority reset was too aggressive and cutting boxes short
    // // Priority: If we have a new relative high, always start fresh (except when we already have a fully confirmed box)
    // if newRelativeHigh and boxState != "BOX_FULLY_CONFIRMED"
    //     potentialCeiling := high
    //     highBarIndex := bar_index
    //     ceilingConfDaysCount := 0
    //     // resets
    //     runningFloorMin := na
    //     barsSinceHigh := 0
    //     floorConfDaysCount := 0
    //     potentialFloor := na
    //     boxState := "SEEKING_CEILING_CONF"

    //     // Debug: Show when we detect a new relative high that overrides current state
    //     if showDebugLabels and boxState != "IDLE"
    //         label.new(bar_index, high + (high * 0.03),
    //                  "PRIORITY RESET\nNew Rel High: " + str.tostring(high) + "\nOverriding: " + boxState,
    //                  style=label.style_label_down, color=color.fuchsia, textcolor=color.white, size=size.small)

    if boxState == "IDLE"
        // Start when we print a new relative high within lookback period (no volume requirement here)
        if newRelativeHigh
            potentialCeiling := high
            highBarIndex := bar_index
            ceilingConfDaysCount := 0
            // resets
            runningFloorMin := na
            barsSinceHigh := 0
            floorConfDaysCount := 0
            potentialFloor := na
            boxState := "SEEKING_CEILING_CONF"

            // Debug: Show when we detect a new relative high
            if shouldShowDebug()
                label.new(bar_index, high + (high * 0.03),
                         "NEW REL HIGH\nPrice: " + str.tostring(high) + "\nStarting ceiling hunt",
                         style=label.style_label_down, color=color.lime, textcolor=color.black, size=size.small)

    else if boxState == "SEEKING_CEILING_CONF"
        // If a higher high appears -> reset potential ceiling and counter
        if high > potentialCeiling
            potentialCeiling := high
            highBarIndex := bar_index
            ceilingConfDaysCount := 0
            // resets
            runningFloorMin := na
            barsSinceHigh := 0
        else
            // No higher high this bar -> count towards confirmation
            ceilingConfDaysCount += 1
            if ceilingConfDaysCount >= ceilingConfirmationDays
                confirmedCeiling := potentialCeiling
                // preparar tracking del suelo
                runningFloorMin := na
                barsSinceHigh := na  // Reset to start counting from ceiling confirmation
                floorConfDaysCount := 0
                potentialFloor := na
                boxState := "CEILING_CONFIRMED"

                // Debug: Ceiling confirmed
                if shouldShowDebug()
                    label.new(bar_index, high + (high * 0.03),
                             "CEILING CONFIRMED\nPrice: " + str.tostring(confirmedCeiling) + "\nBars confirmed: " + str.tostring(ceilingConfDaysCount) +
                             "\nNow looking for floor...",
                             style=label.style_label_down, color=color.lime, textcolor=color.black, size=size.small)

    else if boxState == "CEILING_CONFIRMED"
        // Start counting bars after the ceiling was CONFIRMED (not the original high)
        barsSinceHigh := na(barsSinceHigh) ? 0 : barsSinceHigh + 1

        // Debug: Show waiting period
        if shouldShowDebug() and barsSinceHigh < minBarsAfterHighForFloor
            label.new(bar_index, high + (high * 0.01),
                     "WAITING\nBars: " + str.tostring(barsSinceHigh) + "/" + str.tostring(minBarsAfterHighForFloor) +
                     "\nCurrent Low: " + str.tostring(low),
                     style=label.style_label_down, color=color.white, textcolor=color.black, size=size.tiny)

        // Only start floor tracking after X bars (latency period)
        if barsSinceHigh >= minBarsAfterHighForFloor
            // Update running minimum, but only confirm it after N bars
            if na(runningFloorMin)
                // IMPORTANT: Use the historical minimum from the ENTIRE period since ceiling confirmation
                historicalLow = low
                // Look back through all bars since the ceiling was confirmed (not just barsSinceHigh)
                barsToLookBack = bar_index - highBarIndex
                for j = 1 to barsToLookBack
                    if not na(low[j])
                        historicalLow := math.min(historicalLow, low[j])

                runningFloorMin := historicalLow  // Use true historical minimum
                floorConfDaysCount := 0

                // Debug: First floor candidate with historical context
                if shouldShowDebug()
                    label.new(bar_index, low - (low * 0.01),
                             "FLOOR START\nCurrent: " + str.tostring(low) + "\nHistorical: " + str.tostring(historicalLow) +
                             "\nBars looked back: " + str.tostring(barsToLookBack) + 
                             "\nHighBarIndex: " + str.tostring(highBarIndex) + "\nCurrent Bar: " + str.tostring(bar_index) +
                             "\nCeiling: " + str.tostring(confirmedCeiling) + "\nAnnual Filter: " + str.tostring(useAnnualHighFilter),
                             style=label.style_label_up, color=color.purple, textcolor=color.white, size=size.small)
            else if low < runningFloorMin
                // New lower low found - reset confirmation and update minimum
                runningFloorMin := low
                floorConfDaysCount := 0

                // Debug: Floor update
                if showDebugLabels
                    label.new(bar_index, low - (low * 0.01),
                             "FLOOR UPDATE\nNew Low: " + str.tostring(low) + "\nCount reset: 0",
                             style=label.style_label_up, color=color.orange, textcolor=color.white, size=size.tiny)
            else
                // Always recheck if we have the true minimum from the entire period
                barsToCheck = bar_index - highBarIndex
                trueMinimum = low
                for j = 1 to barsToCheck
                    if not na(low[j])
                        trueMinimum := math.min(trueMinimum, low[j])
                
                // If we found a lower minimum, update it
                if trueMinimum < runningFloorMin
                    runningFloorMin := trueMinimum
                    floorConfDaysCount := 0  // Reset confirmation
                    
                    // Debug: Floor update with true minimum
                    if shouldShowDebug()
                        label.new(bar_index, low - (low * 0.01),
                                 "FLOOR UPDATE (TRUE MIN)\nNew Low: " + str.tostring(trueMinimum) + "\nBars checked: " + str.tostring(barsToCheck),
                                 style=label.style_label_up, color=color.red, textcolor=color.white, size=size.tiny)
                else
                    // No new low - increment confirmation counter
                    floorConfDaysCount += 1

                // Debug: Floor confirmation progress
                if showDebugLabels and floorConfDaysCount <= floorConfirmationDays
                    label.new(bar_index, low - (low * 0.01),
                             "FLOOR CONFIRM\nCount: " + str.tostring(floorConfDaysCount) + "/" + str.tostring(floorConfirmationDays) +
                             "\nFloor: " + str.tostring(runningFloorMin),
                             style=label.style_label_up, color=color.gray, textcolor=color.white, size=size.tiny)

            // Only confirm floor after N bars without new lows
            if floorConfDaysCount >= floorConfirmationDays
                confirmedFloor := runningFloorMin

                // Debug: Floor confirmed
                if showDebugLabels
                    label.new(bar_index, low - (low * 0.01),
                             "FLOOR CONFIRMED\nPrice: " + str.tostring(confirmedFloor) + "\nBars confirmed: " + str.tostring(floorConfDaysCount) +
                             "\nChecking box quality...",
                             style=label.style_label_up, color=color.blue, textcolor=color.white, size=size.small)

                // Box quality checks
                boxHeightPct = (confirmedCeiling - confirmedFloor) / confirmedCeiling * 100.0
                barsInBox    = bar_index - highBarIndex

                // Debug label for box quality check
                if shouldShowDebug()
                    qualityResult = (barsInBox >= minBarsInBox) and (boxHeightPct >= minBoxHeightPct) ? "PASSED" : "FAILED"
                    label.new(bar_index, low - (low * 0.02),
                             "BOX QUALITY " + qualityResult + "\nBars: " + str.tostring(barsInBox) + " (min:" + str.tostring(minBarsInBox) + ")" +
                             "\nHeight: " + str.tostring(boxHeightPct, "#.##") + "% (min:" + str.tostring(minBoxHeightPct) + "%)" +
                             "\nCeiling: " + str.tostring(confirmedCeiling) + "\nFloor: " + str.tostring(confirmedFloor),
                             style=label.style_label_up, color=color.yellow, textcolor=color.black, size=size.small)

                if (barsInBox >= minBarsInBox) and (boxHeightPct >= minBoxHeightPct)
                    boxState := "BOX_FULLY_CONFIRMED"

                    // COMMENTED OUT BOX DELETION FOR DEBUGGING
                    // // Only delete the current box if it hasn't been broken yet
                    // // This preserves broken boxes on the chart for visual reference
                    // if not na(currentBox) and not boxWasBroken
                    //     box.delete(currentBox)

                    // Debug: Show box creation parameters before creating the box
                    if shouldShowDebug()
                        preCreate1 = "PRE-BOX CREATE\nLeft Bar: " + str.tostring(highBarIndex)
                        preCreate2 = " Right Bar: " + str.tostring(bar_index)
                        preCreate3 = "\nTop: " + str.tostring(confirmedCeiling)
                        preCreate4 = " Bottom: " + str.tostring(confirmedFloor)
                        preCreateInfo = preCreate1 + preCreate2 + preCreate3 + preCreate4
                        label.new(bar_index, confirmedCeiling + (confirmedCeiling * 0.01), preCreateInfo,
                                 style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.small)

                    // Create box with highly visible colors for debugging
                    // Use original coordinates - the problem was elsewhere

                    // Pine Script box.new(left, top, right, bottom)
                    currentBox := box.new(left=highBarIndex, top=confirmedCeiling, right=bar_index, bottom=confirmedFloor,
                                          border_color=color.new(color.blue, 100), border_width=0, bgcolor=color.new(color.blue, 70))

                    currentBoxTop    := confirmedCeiling
                    currentBoxBottom := confirmedFloor
                    boxWasBroken     := false  // Reset breakout flag for new box

                    // Debug label for successful box creation
                    if shouldShowDebug()
                        boxInfo1 = "BOX CREATED ✓\nLeft: " + str.tostring(highBarIndex) + " Right: " + str.tostring(bar_index)
                        boxInfo2 = "\nTop: " + str.tostring(confirmedCeiling) + " Bottom: " + str.tostring(confirmedFloor)
                        boxInfo3 = "\nBox Exists: " + (na(currentBox) ? "NO" : "YES")
                        boxInfo4 = "\nWidth: " + str.tostring(bar_index - highBarIndex) + " bars"
                        boxInfo5 = "\nHeight: " + str.tostring(confirmedCeiling - confirmedFloor)
                        boxInfo = boxInfo1 + boxInfo2 + boxInfo3 + boxInfo4 + boxInfo5
                        label.new(bar_index, high + (high * 0.02), boxInfo,
                                 style=label.style_label_down, color=color.green, textcolor=color.white, size=size.normal)
                else
                    // If quality not met, continue looking for floor (don't activate box)
                    floorConfDaysCount := 0

                    // Debug: Why box creation failed
                    if showDebugLabels
                        failReason = ""
                        if barsInBox < minBarsInBox
                            failReason := "Width: " + str.tostring(barsInBox) + "<" + str.tostring(minBarsInBox)
                        if boxHeightPct < minBoxHeightPct
                            failReason := failReason + (failReason != "" ? " & " : "") + "Height: " + str.tostring(boxHeightPct, "#.##") + "%<" + str.tostring(minBoxHeightPct) + "%"

                        label.new(bar_index, high + (high * 0.02),
                                 "BOX REJECTED\n" + failReason + "\nCeiling: " + str.tostring(confirmedCeiling) + "\nFloor: " + str.tostring(confirmedFloor),
                                 style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

        // Only reset on SIGNIFICANT higher high, not on every new relative high
        if not na(confirmedCeiling) and high > confirmedCeiling
            // Debug: Sequence interrupted by new high
            if showDebugLabels
                resetReason = "HIGHER HIGH"
                oldCeiling = na(confirmedCeiling) ? "NONE" : str.tostring(confirmedCeiling)
                label.new(bar_index, high + (high * 0.02),
                         "SEQUENCE RESET\n" + resetReason + "\nNew High: " + str.tostring(high) + "\nOld Ceiling: " + oldCeiling +
                         "\nFloor progress lost",
                         style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.small)

            potentialCeiling := high
            highBarIndex := bar_index
            ceilingConfDaysCount := 0
            // Reset floor tracking
            runningFloorMin := na
            barsSinceHigh := 0
            potentialFloor := na
            boxState := "SEEKING_CEILING_CONF"

    else if boxState == "BOX_FULLY_CONFIRMED"
        // If a new higher high forms, start hunting for the next box
        if high > confirmedCeiling
            // COMMENTED OUT BOX DELETION FOR DEBUGGING
            // // Only delete current box if it hasn't been broken yet
            // // This preserves broken boxes on the chart for visual reference
            // if not na(currentBox) and not boxWasBroken
            //     box.delete(currentBox)

            // currentBox := na
            // currentBoxTop := na
            // currentBoxBottom := na

            potentialCeiling := high
            highBarIndex := bar_index
            ceilingConfDaysCount := 0
            // resets
            runningFloorMin := na
            barsSinceHigh := 0
            floorConfDaysCount := 0
            potentialFloor := na
            boxState := "SEEKING_CEILING_CONF"

// Handle current active box - extend it properly
if not na(currentBox) and not na(currentBoxTop) and not na(currentBoxBottom)
    // Calculate tolerance levels
    toleranceUp = currentBoxTop * (1 + breakoutTolerancePct / 100)
    toleranceDown = currentBoxBottom * (1 - breakoutTolerancePct / 100)

    // Check for breakout on current bar with tolerance
    currentBreakout = high > toleranceUp or low < toleranceDown

    if currentBreakout and not boxWasBroken
        // Box is being broken right now - close it at current bar to show the breakout
        box.set_right(currentBox, bar_index)
        boxWasBroken := true

        // Debug label for breakout
        if showDebugLabels
            breakoutType = high > toleranceUp ? "CEILING BREAK" : "FLOOR BREAK"
            breakoutPrice = high > toleranceUp ? str.tostring(high) : str.tostring(low)
            toleranceLevel = high > toleranceUp ? str.tostring(toleranceUp) : str.tostring(toleranceDown)
            label.new(bar_index, high + (high * 0.01),
                     breakoutType + "\nPrice: " + breakoutPrice + "\nTolerance: " + toleranceLevel +
                     "\nBox Top: " + str.tostring(currentBoxTop) + "\nBox Bot: " + str.tostring(currentBoxBottom) +
                     "\nTolerance %: " + str.tostring(breakoutTolerancePct),
                     style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

        // Execute trade immediately on ceiling breakout
        if high > toleranceUp and strategy.position_size == 0 and volumeOnBreakout and isBullMarket and passAnnualFilter
            strategy.entry("Darvas Buy", strategy.long)
            entryBoxTop := currentBoxTop
            currentStopLoss := currentBoxBottom
            
            // Debug trade execution
            if showDebugLabels
                label.new(bar_index, high + (high * 0.03),
                         "TRADE EXECUTED ✓\nEntry Price: " + str.tostring(close) + 
                         "\nStop Loss: " + str.tostring(currentBoxBottom),
                         style=label.style_label_down, color=color.green, textcolor=color.white, size=size.small)

        // Keep the box visible after breakout - don't delete it immediately
        // Only clear the tracking variables, not the box itself
        currentBoxTop := na
        currentBoxBottom := na
    else if not currentBreakout and not boxWasBroken
        // Price is still within box - extend to current bar
        box.set_right(currentBox, bar_index)

        // Debug: Show daily breakout check details for active boxes
        if shouldShowDebug()
            debugText1 = "DAILY CHECK\nHigh: " + str.tostring(high)
            debugText2 = "\nBox Top: " + str.tostring(currentBoxTop)
            debugText3 = "\nTolerance: " + str.tostring(toleranceUp)
            debugText4 = "\nBreakout?: " + str.tostring(high > toleranceUp)
            debugText5 = "\nTol%: " + str.tostring(breakoutTolerancePct)
            debugText = debugText1 + debugText2 + debugText3 + debugText4 + debugText5
            label.new(bar_index, high + (high * 0.005), debugText,
                     style=label.style_label_down, color=color.yellow, textcolor=color.black, size=size.tiny)

// =============================================================================
//                          BUY AND SELL LOGIC
// =============================================================================

// Entry: breakout above CONFIRMED ceiling + (optional) volume + (optional) bull market
// NOTE: Trade execution now happens directly in the breakout detection logic above

// Trailing stop: move to the FLOOR of the current active box if it's higher
if strategy.position_size > 0
    newStopLoss = currentStopLoss
    if not na(currentBoxTop) and not na(currentBoxBottom)
        // Use current active box for trailing stop
        if not na(entryBoxTop) and currentBoxTop > entryBoxTop and currentBoxBottom > currentStopLoss
            newStopLoss := currentBoxBottom

    if newStopLoss != currentStopLoss
        currentStopLoss := newStopLoss

    // Exit via stop-loss at current box floor
    strategy.exit("SL", from_entry="Darvas Buy", stop=currentStopLoss)

// Bear market hard exit (if enabled)
if strategy.position_size > 0 and useMarketFilter and not isBullMarket
    strategy.close("Darvas Buy", comment="Bear Market - Exit All Positions")

// =============================================================================
//                              VISUALIZATION
// =============================================================================

// Annual high line (optional - based on configured lookback period)
plot(showAnnualHigh ? fiftyTwoWeekHigh : na, title="Annual High Line", color=color.new(color.orange, 20), style=plot.style_linebr)

// Volume threshold (only if filter is enabled)
plot(useVolumeFilter ? avgVolume * volumeMultiplier : na, title="Breakout Volume Threshold", color=color.red, linewidth=2, style=plot.style_linebr, display=display.data_window)

// Market background
// var bgcolor_color = useMarketFilter ? (isBullMarket ? color.new(color.green, 95) : color.new(color.red, 95)) : na
// bgcolor(bgcolor_color, title="Market Trend Background")

// Active stop loss
plot(strategy.position_size > 0 ? currentStopLoss : na, title="Active Stop Loss", color=color.red, linewidth=2, style=plot.style_linebr)

// Debug: Show current box status every 10 bars
if showDebugLabels and bar_index % 10 == 0
    debugText1 = "DEBUG STATUS\nBox State: " + boxState
    debugText2 = "\nCurrent Box: " + (na(currentBox) ? "NONE" : "EXISTS")
    debugText3 = "\nBox Top: " + (na(currentBoxTop) ? "NONE" : str.tostring(currentBoxTop))
    debugText4 = "\nBox Bottom: " + (na(currentBoxBottom) ? "NONE" : str.tostring(currentBoxBottom))
    debugText5 = "\nBox Broken: " + str.tostring(boxWasBroken)
    debugText6 = "\nBull Market: " + str.tostring(isBullMarket)
    debugText7 = "\nAnnual Filter: " + str.tostring(passAnnualFilter)
    debugText8 = "\nNew Rel High: " + str.tostring(newRelativeHigh)
    debugText9 = "\nRecent High: " + str.tostring(recentHigh)
    debugText = debugText1 + debugText2 + debugText3 + debugText4 + debugText5 + debugText6 + debugText7 + debugText8 + debugText9
    label.new(bar_index, high + (high * 0.01), debugText,
             style=label.style_label_down, color=color.white, textcolor=color.black, size=size.small)
