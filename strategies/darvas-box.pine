//@version=6
strategy("Darvas Box Strategy", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=10, commission_value=0.1, max_labels_count=500, max_boxes_count=500)

// =============================================================================
//                            CONFIGURATION (INPUTS)
// =============================================================================

// -- Optional Annual High Filter
useAnnualHighFilter = input.bool(false, title="Use Annual High Proximity Filter", group="Filters", tooltip="Only form boxes when price is near its annual high. Helps filter for strongest stocks.")
annualLookback      = input.int(252, title="Annual High Lookback (days)", group="Filters", minval=50, tooltip="Period to calculate annual high. 252 = ~1 trading year")
nearHighPercent     = input.float(5.0, title="Proximity to Annual High (%)", group="Filters", minval=0.0, tooltip="How close price must be to annual high to qualify. 5% means within 5% of the high.")

// -- Relative High Lookback Period
recentHighLookback  = input.int(20, title="Relative High Lookback Period (days)", group="Filters", minval=5, tooltip="Period to look back for relative highs. 252 = ~1 year, 20 = ~1 month")

// -- Darvas Box Confirmation (classic)
ceilingConfirmationDays = input.int(3, title="Bars to Confirm Box Ceiling", group="Box Logic", minval=2, tooltip="Number of bars without new highs to confirm box ceiling. Classic Darvas uses 3.")
floorConfirmationDays   = input.int(3, title="Bars to Confirm Box Floor", group="Box Logic", minval=2, tooltip="Number of bars without new lows to confirm box floor. Classic Darvas uses 3.")

// -- Minimum box quality filters
minBarsInBox            = input.int(6, title="Minimum Bars Inside Box", group="Box Logic", minval=3, tooltip="Minimum width of box in bars. Filters out narrow/short-lived boxes.")
minBoxHeightPct         = input.float(1.0, title="Minimum Box Height (%)", group="Box Logic", minval=0.0, tooltip="Minimum height of box as percentage. 1% means box must be at least 1% from floor to ceiling.")

// -- Floor confirmation latency
minBarsAfterHighForFloor = input.int(1, title="Min Bars After High Before Floor Search", group="Box Logic", minval=0, tooltip="Bars to wait after ceiling confirmation before starting floor search. Ensures proper pullback.")

// -- Breakout tolerance
breakoutTolerancePct = input.float(0.0, title="Breakout Tolerance (%)", group="Box Logic", minval=0.0, maxval=5.0, tooltip="Percentage tolerance for breakouts. Prevents box closure from minor wicks. 0.0% = immediate breakout detection.")

// -- Volume Filter (only at breakout)
useVolumeFilter     = input.bool(true, title="Enable Volume Filter on Breakout", group="Filters", tooltip="Require high volume on breakout. Helps confirm genuine breakouts vs false signals.")
volumeLookback      = input.int(50, title="Volume MA Period", group="Filters", minval=5, tooltip="Period for volume moving average calculation. Used as baseline for volume comparison.")
volumeMultiplier    = input.float(1.5, title="Volume Multiplier (e.g., 1.5 = 50% above average)", group="Filters", minval=1.0, tooltip="Volume must be this many times above average. 1.5 = 50% above average volume.")

// -- Market Trend Filter
useMarketFilter     = input.bool(true, title="Enable Market Trend Filter", group="Filters", tooltip="Only trade when overall market is bullish. Darvas emphasized market conditions.")
marketTicker        = input.symbol("SPY", title="Market Index Ticker", group="Filters", tooltip="Market index to use for trend filter. SPY = S&P 500, QQQ = Nasdaq, etc.")
marketLookback      = input.int(200, title="Market SMA Period", group="Filters", minval=50, tooltip="SMA period for market trend. Market bullish when above this SMA. 200 is common long-term trend.")

// -- Visuals
showAnnualHigh      = input.bool(true, title="Show Annual High Line", group="Visualization", tooltip="Display the annual high line on chart for reference.")
boxColor            = input.color(color.new(color.blue, 80), title="Box Color", group="Visualization", tooltip="Color and transparency for Darvas boxes. Lighter colors show more price action.")
showDebugLabels     = input.bool(false, title="Show Debug Labels", group="Visualization", tooltip="Show debug information about box state and breakout detection.")
debugStartDate      = input.time(timestamp("01 Dec 2020"), title="Debug Start Date", group="Visualization", tooltip="Start date for showing debug labels")
debugEndDate        = input.time(timestamp("31 Jan 2021"), title="Debug End Date", group="Visualization", tooltip="End date for showing debug labels")

// =============================================================================
//                               BASIC CALCULATIONS
// =============================================================================

// Market Condition
marketClose = request.security(marketTicker, "1D", close)
marketSma   = ta.sma(marketClose, marketLookback)

// Annual high proximity
float fiftyTwoWeekHigh = ta.highest(high[1], annualLookback)

// Volume
float avgVolume = ta.sma(volume[1], volumeLookback)

// Helper function to determine if we should show debug labels
shouldShowDebug() => showDebugLabels and (time >= debugStartDate and time <= debugEndDate)

// =============================================================================
//                            VALIDATE_MARKET_CONDITIONS
// =============================================================================
// @description: Validates all market condition filters including bull market,
//               annual high proximity, and volume requirements for trading
// @param marketSma (float) : Market simple moving average
// @param marketPrice (float) : Current market price
// @param annualHigh (float) : 52-week high price
// @param currentPrice (float) : Current stock price
// @param volume (float) : Current volume
// @param avgVolume (float) : Average volume for comparison
// @returns (bool) : true if all market conditions are satisfied
// @example: validateMarketConditions(marketSma, marketClose, fiftyTwoWeekHigh, high, volume, avgVolume)
// @complexity: O(1) - Multiple simple condition checks
// @sideEffects: None - pure validation function
// =============================================================================
validateMarketConditions(marketSmaVal, marketPrice, annualHigh, currentPrice, currentVolume, avgVol, volumeMult) =>
    isBullMarket = useMarketFilter ? (marketPrice > marketSmaVal) : true
    isNear52WeekHigh = currentPrice > annualHigh * (1 - nearHighPercent / 100)
    passAnnualFilter = useAnnualHighFilter ? isNear52WeekHigh : true
    volumeOnBreakout = useVolumeFilter ? (currentVolume > avgVol * volumeMult) : true
    [isBullMarket, passAnnualFilter, volumeOnBreakout]

// =============================================================================
//                            DETECT_RELATIVE_HIGH
// =============================================================================
// @description: Detects if the price current forms a new relative high
//               compared with a lookback period configurable
// @param currentHigh (float) : Current bar's high price
// @param lookbackPeriod (int) : Number of bars to look back for comparison
// @returns (bool) : true if new relative high is detected
// @example: detectRelativeHigh(high, 20)
// @complexity: O(1) - Uses ta.highest() optimized
// @sideEffects: None - pure function
// =============================================================================
detectRelativeHigh(currentHigh, lookbackPeriod) =>
    float recentHigh = ta.highest(high[1], lookbackPeriod)
    currentHigh > recentHigh

// =============================================================================
//                            CONFIRM_CEILING
// =============================================================================
// @description: Confirms the ceiling of a Darvas box after N bars
//               without new highs higher than the potential ceiling
// @param potentialCeiling (float) : Price of the ceiling candidate
// @param currentHigh (float) : Current high price
// @param confirmationDays (int) : Required days without new highs
// @param currentCount (int) : Current confirmation counter
// @returns ([bool, int, float]) : [confirmed, newCount, newCeiling]
// @example: confirmCeiling(potentialCeiling, high, 3, ceilingConfDaysCount)
// @complexity: O(1) - Simple comparison
// @sideEffects: None - pure function
// =============================================================================
confirmCeiling(potentialCeil, currentHigh, confirmationDays, currentCount) =>
    if currentHigh > potentialCeil
        [false, 0, currentHigh]  // Reset counter, new ceiling
    else
        newCount = currentCount + 1
        isConfirmed = newCount >= confirmationDays
        [isConfirmed, newCount, potentialCeil]

// =============================================================================
//                            FIND_HISTORICAL_FLOOR
// =============================================================================
// @description: Finds the historical minimum price from ceiling confirmation
//               to current bar, ensuring true floor detection across the period
// @param highBarIndex (int) : Bar index where ceiling was confirmed
// @param currentBarIndex (int) : Current bar index
// @param currentLow (float) : Current bar's low price
// @returns (float) : Historical minimum price in the period
// @example: findHistoricalFloor(highBarIndex, bar_index, low)
// @complexity: O(n) where n = bars since ceiling confirmation
// @sideEffects: None - pure calculation function
// =============================================================================
findHistoricalFloor(highBarIdx, currentBarIdx, currentLow) =>
    historicalLow = currentLow
    barsToLookBack = currentBarIdx - highBarIdx
    for j = 1 to barsToLookBack
        if not na(low[j])
            historicalLow := math.min(historicalLow, low[j])
    historicalLow

// =============================================================================
//                            CONFIRM_FLOOR
// =============================================================================
// @description: Confirms Darvas box floor after N bars without lower lows,
//               following classic Darvas methodology for floor validation
// @param runningFloorMin (float) : Current minimum floor candidate
// @param currentLow (float) : Current bar's low price
// @param confirmationDays (int) : Required days without new lows
// @param currentCount (int) : Current confirmation counter
// @param minBarsAfterHigh (int) : Minimum bars required after ceiling
// @param barsSinceHigh (int) : Actual bars since ceiling confirmation
// @param highBarIdx (int) : Bar index of ceiling confirmation
// @param currentBarIdx (int) : Current bar index
// @returns ([bool, int, float]) : [confirmed, newCount, newFloor]
// @example: confirmFloor(runningFloorMin, low, 3, floorConfDaysCount, 1, barsSinceHigh, highBarIndex, bar_index)
// @complexity: O(n) - May need to recalculate historical minimum
// @sideEffects: None - pure function
// =============================================================================
confirmFloor(runningFloor, currentLow, confirmationDays, currentCount, minBarsAfterHigh, barsSinceHigh, highBarIdx, currentBarIdx) =>
    // Only start floor tracking after minimum bars
    if barsSinceHigh < minBarsAfterHigh
        [false, currentCount, runningFloor]
    else
        // Initialize floor if not set
        if na(runningFloor)
            historicalFloor = findHistoricalFloor(highBarIdx, currentBarIdx, currentLow)
            [false, 0, historicalFloor]
        else if currentLow < runningFloor
            // New lower low found - reset confirmation
            [false, 0, currentLow]
        else
            // Check for true minimum from entire period
            trueMinimum = findHistoricalFloor(highBarIdx, currentBarIdx, currentLow)
            if trueMinimum < runningFloor
                [false, 0, trueMinimum]
            else
                newCount = currentCount + 1
                isConfirmed = newCount >= confirmationDays
                [isConfirmed, newCount, runningFloor]

// =============================================================================
//                            VALIDATE_BOX_QUALITY
// =============================================================================
// @description: Validates if a potential Darvas box meets quality standards
//               including minimum width, height percentage, and other criteria
// @param ceiling (float) : Confirmed ceiling price
// @param floor (float) : Confirmed floor price
// @param boxWidth (int) : Width of box in bars
// @param minBarsInBox (int) : Minimum required bars
// @param minBoxHeightPct (float) : Minimum height percentage required
// @returns (bool) : true if box meets all quality standards
// @example: validateBoxQuality(confirmedCeiling, confirmedFloor, barsInBox, 6, 1.0)
// @complexity: O(1) - Simple mathematical validations
// @sideEffects: None - pure validation function
// =============================================================================
validateBoxQuality(ceiling, floor, boxWidth, minBars, minHeightPct) =>
    boxHeightPct = (ceiling - floor) / ceiling * 100.0
    (boxWidth >= minBars) and (boxHeightPct >= minHeightPct)

// =============================================================================
//                            CREATE_DARVAS_BOX
// =============================================================================
// @description: Creates a visual Darvas box on the chart with proper styling
//               and updates all related tracking variables
// @param leftBar (int) : Left boundary bar index (ceiling confirmation)
// @param rightBar (int) : Right boundary bar index (current bar)
// @param topPrice (float) : Top boundary price (confirmed ceiling)
// @param bottomPrice (float) : Bottom boundary price (confirmed floor)
// @param boxStyle (color) : Color and transparency for the box
// @returns (box) : Pine Script box object reference
// @example: createDarvasBox(highBarIndex, bar_index, confirmedCeiling, confirmedFloor, boxColor)
// @complexity: O(1) - Single box creation operation
// @sideEffects: Creates visual box on chart
// =============================================================================
createDarvasBox(leftBar, rightBar, topPrice, bottomPrice, boxStyle) =>
    box.new(left=leftBar, top=topPrice, right=rightBar, bottom=bottomPrice, border_color=color.new(color.green, 50), border_width=1, bgcolor=color.new(color.green, 80))

// =============================================================================
//                            DETECT_BREAKOUT
// =============================================================================
// @description: Detects ceiling or floor breakouts from active Darvas boxes
//               with configurable tolerance levels for robust signal generation
// @param boxTop (float) : Top boundary of the active box
// @param boxBottom (float) : Bottom boundary of the active box
// @param currentHigh (float) : Current bar's high price
// @param currentLow (float) : Current bar's low price
// @param tolerancePct (float) : Breakout tolerance percentage
// @returns (string) : "CEILING_BREAK", "FLOOR_BREAK", or "NO_BREAK"
// @example: detectBreakout(currentBoxTop, currentBoxBottom, high, low, breakoutTolerancePct)
// @complexity: O(1) - Simple price comparison with tolerance calculation
// @sideEffects: None - pure function
// =============================================================================
detectBreakout(boxTop, boxBottom, currentHigh, currentLow, tolerancePct) =>
    toleranceUp = boxTop
    toleranceDown = boxBottom * (1 - tolerancePct / 100)

    if currentHigh > toleranceUp
        "CEILING_BREAK"
    else if currentLow < toleranceDown
        "FLOOR_BREAK"
    else
        "NO_BREAK"

// =============================================================================
//                            UPDATE_BOX_COLORS
// =============================================================================
// @description: Updates Darvas box colors based on breakout status and violations
//               Green=Active, Red=Floor Break, Yellow=Stop Loss Violation
// @param boxRef (box) : Reference to the Pine Script box object
// @param breakoutType (string) : Type of breakout ("CEILING", "FLOOR", "STOP_VIOLATION")
// @returns (void) : No return value - modifies box appearance
// @example: updateBoxColors(currentBox, "FLOOR_BREAK")
// @complexity: O(1) - Direct box property modification
// @sideEffects: Changes visual appearance of boxes on chart
// =============================================================================
updateBoxColors(boxRef, breakoutType) =>
    if breakoutType == "FLOOR_BREAK"
        box.set_bgcolor(boxRef, color.new(color.red, 80))
        box.set_border_color(boxRef, color.new(color.red, 50))
    else if breakoutType == "STOP_VIOLATION"
        box.set_bgcolor(boxRef, color.new(color.yellow, 80))
        box.set_border_color(boxRef, color.new(color.yellow, 50))

// =============================================================================
//                            CHECK_STOP_VIOLATION
// =============================================================================
// @description: Checks if current price violates previous stop loss levels
//               and triggers appropriate visual and trading responses
// @param currentLow (float) : Current bar's low price
// @param previousStopLoss (float) : Previous box's stop loss level
// @param violationFlag (bool) : Current violation status flag
// @returns (bool) : true if violation detected and not already flagged
// @example: checkStopViolation(low, previousStopLoss, currentBoxViolatedPreviousStop)
// @complexity: O(1) - Simple price comparison
// @sideEffects: None - pure function
// =============================================================================
checkStopViolation(currentLow, previousStop, violationFlag) =>
    not na(previousStop) and currentLow < previousStop and not violationFlag

// =============================================================================
//                            CALCULATE_TRAILING_STOP
// =============================================================================
// @description: Calculates trailing stop loss following Darvas methodology
//               Only moves stop higher when new box forms at higher level
// @param currentStop (float) : Current stop loss level
// @param entryBoxTop (float) : Top of the entry box
// @param newBoxTop (float) : Top of the new active box
// @param newBoxBottom (float) : Bottom of the new active box
// @returns (float) : New stop loss level or current if no update
// @example: calculateTrailingStop(currentStopLoss, entryBoxTop, currentBoxTop, currentBoxBottom)
// @complexity: O(1) - Simple comparison and assignment
// @sideEffects: None - pure calculation function
// =============================================================================
calculateTrailingStop(currentStop, entryTop, newTop, newBottom) =>
    if not na(entryTop) and newTop > entryTop and newBottom > currentStop
        newBottom
    else
        currentStop

// =============================================================================
//                            DEBUG_BOX_INFO
// =============================================================================
// @description: Creates debug labels with comprehensive box formation information
//               only during specified debug date ranges for performance
// @param debugEnabled (bool) : Master debug toggle
// @param labelText (string) : Text content for the debug label
// @param barIdx (int) : Bar index for label placement
// @param priceLevel (float) : Price level for label placement
// @param labelColor (color) : Color for the debug label
// @param labelStyle (string) : Label style identifier
// @returns (void) : No return value - creates visual debug labels
// @example: debugBoxInfo(shouldShowDebug(), "Debug info", bar_index, high, color.lime, "down")
// @complexity: O(1) - Conditional label creation
// @sideEffects: Creates debug labels on chart when conditions met
// =============================================================================
debugBoxInfo(debugEnabled, labelText, barIdx, priceLevel, labelColor, labelStyle) =>
    if debugEnabled
        style = labelStyle == "down" ? label.style_label_down : label.style_label_up
        label.new(barIdx, priceLevel, labelText, style=style, color=labelColor, textcolor=color.white, size=size.small)

// =============================================================================
//                         DARVAS BOX FORMATION LOGIC (REFACTORED)
// =============================================================================

var string boxState = "IDLE"
var float potentialCeiling = na
var float potentialFloor   = na
var float confirmedCeiling = na
var float confirmedFloor   = na
var int   ceilingConfDaysCount = 0
var int   floorConfDaysCount   = 0
var int   highBarIndex = na
var int   barsSinceHigh = na
var float runningFloorMin = na
var bool  boxWasBroken = false

// Single active Darvas box
var box currentBox = na
var float currentBoxTop = na
var float currentBoxBottom = na

// Trade tracking variables
var float entryBoxTop = na
var float currentStopLoss = na
var float lastValidStopLoss = na
var float previousStopLoss = na
var bool currentBoxViolatedPreviousStop = false

// Get market conditions
[isBullMarket, passAnnualFilter, volumeOnBreakout] = validateMarketConditions(marketSma, marketClose, fiftyTwoWeekHigh, high, volume, avgVolume, volumeMultiplier)

// Check for new relative high
newRelativeHigh = detectRelativeHigh(high, recentHighLookback)

// Debug: Show relative high detection
if shouldShowDebug()
    hhStatus = newRelativeHigh ? "✓ NEW HH!" : "No HH"
    hhColor = newRelativeHigh ? color.lime : color.gray
    debugText = "HH CHECK\n" + hhStatus + "\nO:" + str.tostring(open, "#.##") + " H:" + str.tostring(high, "#.##") + "\nL:" + str.tostring(low, "#.##") + " C:" + str.tostring(close, "#.##") + "\nPrevMax: " + str.tostring(ta.highest(high[1], recentHighLookback), "#.##") + "\nLookback: " + str.tostring(recentHighLookback) + "d"
    debugBoxInfo(true, debugText, bar_index, high + (high * 0.005), hhColor, "down")

// Main state machine (simplified)
if isBullMarket and passAnnualFilter
    if boxState == "IDLE"
        if newRelativeHigh
            potentialCeiling := high
            highBarIndex := bar_index
            ceilingConfDaysCount := 0
            runningFloorMin := na
            barsSinceHigh := 0
            floorConfDaysCount := 0
            potentialFloor := na
            boxState := "SEEKING_CEILING_CONF"

            if shouldShowDebug()
                debugText = "NEW REL HIGH ✓\nCurrent: " + str.tostring(high) + "\nStarting ceiling hunt"
                debugBoxInfo(true, debugText, bar_index, high + (high * 0.03), color.lime, "down")

    else if boxState == "SEEKING_CEILING_CONF"
        [isConfirmed, newCount, newCeiling] = confirmCeiling(potentialCeiling, high, ceilingConfirmationDays, ceilingConfDaysCount)
        ceilingConfDaysCount := newCount
        potentialCeiling := newCeiling

        if high > potentialCeiling
            highBarIndex := bar_index
            runningFloorMin := na
            barsSinceHigh := 0

        if isConfirmed
            confirmedCeiling := potentialCeiling
            runningFloorMin := na
            barsSinceHigh := na
            floorConfDaysCount := 0
            potentialFloor := na
            boxState := "CEILING_CONFIRMED"

            if shouldShowDebug()
                debugText = "CEILING CONFIRMED\nPrice: " + str.tostring(confirmedCeiling) + "\nNow looking for floor..."
                debugBoxInfo(true, debugText, bar_index, high + (high * 0.03), color.lime, "down")

    else if boxState == "CEILING_CONFIRMED"
        barsSinceHigh := na(barsSinceHigh) ? 0 : barsSinceHigh + 1

        [floorConfirmed, newFloorCount, newFloor] = confirmFloor(runningFloorMin, low, floorConfirmationDays, floorConfDaysCount, minBarsAfterHighForFloor, barsSinceHigh, highBarIndex, bar_index)
        floorConfDaysCount := newFloorCount
        runningFloorMin := newFloor

        if floorConfirmed
            confirmedFloor := runningFloorMin
            barsInBox = bar_index - highBarIndex

            if validateBoxQuality(confirmedCeiling, confirmedFloor, barsInBox, minBarsInBox, minBoxHeightPct)
                boxState := "BOX_FULLY_CONFIRMED"

                if shouldShowDebug()
                    debugText = "BOX CREATED ✓\nTop: " + str.tostring(confirmedCeiling) + " Bottom: " + str.tostring(confirmedFloor)
                    debugBoxInfo(true, debugText, bar_index, high + (high * 0.02), color.green, "down")

                currentBox := createDarvasBox(highBarIndex, bar_index, confirmedCeiling, confirmedFloor, boxColor)
                currentBoxTop := confirmedCeiling
                currentBoxBottom := confirmedFloor

                previousStopLoss := lastValidStopLoss
                lastValidStopLoss := confirmedFloor
                currentBoxViolatedPreviousStop := false
                boxWasBroken := false
            else
                floorConfDaysCount := 0

        // Reset on significant higher high
        if not na(confirmedCeiling) and high > confirmedCeiling
            potentialCeiling := high
            highBarIndex := bar_index
            ceilingConfDaysCount := 0
            runningFloorMin := na
            barsSinceHigh := 0
            potentialFloor := na
            boxState := "SEEKING_CEILING_CONF"

    else if boxState == "BOX_FULLY_CONFIRMED"
        if high > confirmedCeiling
            potentialCeiling := high
            highBarIndex := bar_index
            ceilingConfDaysCount := 0
            runningFloorMin := na
            barsSinceHigh := 0
            floorConfDaysCount := 0
            potentialFloor := na
            boxState := "SEEKING_CEILING_CONF"

// Handle active box breakouts
if not na(currentBox) and not na(currentBoxTop) and not na(currentBoxBottom)
    breakoutType = detectBreakout(currentBoxTop, currentBoxBottom, high, low, breakoutTolerancePct)

    if breakoutType != "NO_BREAK" and not boxWasBroken
        box.set_right(currentBox, bar_index)
        boxWasBroken := true

        // Execute trade on ceiling breakout
        if breakoutType == "CEILING_BREAK" and strategy.position_size == 0 and volumeOnBreakout and isBullMarket and passAnnualFilter
            strategy.entry("Darvas Buy", strategy.long)
            entryBoxTop := currentBoxTop
            currentStopLoss := currentBoxBottom
            lastValidStopLoss := currentBoxBottom

        // Update colors
        if breakoutType == "FLOOR_BREAK"
            updateBoxColors(currentBox, "FLOOR_BREAK")

        currentBoxTop := na
        currentBoxBottom := na

    else if breakoutType == "NO_BREAK" and not boxWasBroken
        box.set_right(currentBox, bar_index)

        // Check stop violation
        if checkStopViolation(low, previousStopLoss, currentBoxViolatedPreviousStop)
            updateBoxColors(currentBox, "STOP_VIOLATION")
            currentBoxViolatedPreviousStop := true

// =============================================================================
//                          TRADING LOGIC
// =============================================================================

// Trailing stop management
if strategy.position_size > 0
    newStopLoss = calculateTrailingStop(currentStopLoss, entryBoxTop, currentBoxTop, currentBoxBottom)
    if newStopLoss != currentStopLoss
        currentStopLoss := newStopLoss
        lastValidStopLoss := newStopLoss

    strategy.exit("SL", from_entry="Darvas Buy", stop=currentStopLoss)

// Bear market exit
if strategy.position_size > 0 and useMarketFilter and not isBullMarket
    strategy.close("Darvas Buy", comment="Bear Market - Exit All Positions")

// =============================================================================
//                              VISUALIZATION
// =============================================================================

// Annual high line
plot(showAnnualHigh ? fiftyTwoWeekHigh : na, title="Annual High Line", color=color.new(color.orange, 20), style=plot.style_linebr)

// Volume threshold
plot(useVolumeFilter ? avgVolume * volumeMultiplier : na, title="Breakout Volume Threshold", color=color.red, linewidth=2, style=plot.style_linebr, display=display.data_window)

// Active stop loss
plot(strategy.position_size > 0 ? currentStopLoss : na, title="Active Stop Loss", color=color.red, linewidth=2, style=plot.style_linebr)

// Persistent stop loss level
plot(not na(lastValidStopLoss) ? lastValidStopLoss : na, title="Stop Loss Level", color=color.red, linewidth=1, style=plot.style_circles)

// Debug status every 10 bars
if showDebugLabels and bar_index % 10 == 0
    debugText = "DEBUG STATUS\nBox State: " + boxState + "\nCurrent Box: " + (na(currentBox) ? "NONE" : "EXISTS") + "\nBull Market: " + str.tostring(isBullMarket) + "\nNew Rel High: " + str.tostring(newRelativeHigh)
    debugBoxInfo(true, debugText, bar_index, high + (high * 0.01), color.white, "down")

// Market filter background color
bgcolor(useMarketFilter ? (isBullMarket ? color.new(color.green, 95) : color.new(color.red, 95)) : na, title="Market Trend Background")
